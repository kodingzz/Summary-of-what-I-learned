# 컬렉션 프레임웍
## 컬렉션  
- 여러객체를 모아놓은 것을 의미  

## 프레임웍  
- 표준화,정형화된 체계적인 프로그래밍 방식(정해져있는 프로그래밍방식)  
- 라이브러리: 다른사람이 만들어놓은 기능(정보)을 모아놓은 것  

## 컬렉션 프레임웍  
- 컬렉션(다수의 객체)를 다루기위한 표준화된 프로그래밍 방식  
- 컬렉션을 쉽고 편리하게 다룰 수 있는 다양한 클래스 제공-> 컬렉션 클래스  

## 컬렉션 프레임웍의 핵심 인터페이스  
- List, Set, Map 인터페이스  


## List 인터페이스  
- 순서o,중복 o  
- ArrayList, LinkedList가 핵심  

## Set 인터페이스
- 순서x,중복x  
- HashSet,TreeSet가 핵심  

## Map 인터페이스  
- 순서x,중복(키x,값 o)  
- LinkedHashMap은 순서가 있다.  
- HashMap,TreeMap가 핵심  

## ArrayList  
- List인터페이스를 구현한 클래스  
- 기존의 Vector를 개선힌 것으로 구현원리와 기능적으로 동일하다.  
- ArrayList는 Vector와 달리 동기화가 안돼있다.  
- 객체 저장공간으로 배열을 사용한다.  

## 배열의 장단점 
- 장점: 배열은 구조가 간단하고 데이터를 읽는데 걸리는 시간이 짧다.  
- 단점: 크기를 변경할 수 없고, 비순차적인 데이터의 추가,삭제에 시간이 많이 걸린다.  

## LinkedList 
- 배열의 단점을 보완  
- 배열과 달리 링크드 리시트는 불연속적으로 존재하는 데이터 연결  
- 데이터 삭제: 단 한번의 참조변경만으로 가능하다.  
- 데이터 추가: 한번의 Node객체생성과 두번의 참조변경으로 가능  
- 단점: 데이터 접근성이 나쁘다. 다음 노드의 주소만 알기때문에 한번만에 끝까지 이동이 불가하다.  
- 더블리 링크드 리스트: 이중 연결 리스트, 접근성 향상, 앞뒤에대한 정보를 알게됨.  
- 이중 원형 연결리스트: 마지막요소의 다음을 맨처음, 맨처음의 이전요소를 마지막요소로 지정(원형)  

## ArrayList vs LinkedList 
- 순차적으로 데이터 추가/삭제: ArrayList가 더 빠르다.  
- 비순차적(중간에) 데이터 추가/삭제: LinkedList가 더빠르다.  
- 접근시간: ArrayList가 더빠르다.  
- 읽기 자체는 ArrayList가 더빠르나 변경은 LinkedList가 더빠르다.  

 ## Iterator, ListIterlator Enumeration  
 - 컬렉션에 저장된 데이터를 접근하는데 사용되는 인터페이스  
 - 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화한것 (Iterator)  
 
 ## Map과 Iterator  
 - Map에는 iterator()가 없다.  
 - keySet(),valuses(),entrySet()를 호출해야한다.  

 ## Arrays클래스
 - 배열을 다루기 편리한 메서드 제공  
 - 배열의 출력 - toString()  
 - 배열의 복사 - copyOf(),copyOfRange()  / 새로운 배열을 생성해서 반환  
 - 배열 채우기 - fill(), setAll() 
 - 배열 정렬과 검색 - sort(). binarySearch()(이진탐색)  / 이진탐색은 정렬돼있어야 가능하다.  
 - 다차원 배열의 출력 - deepToString()  
 - 다차원 배열의 비교 - deepEquals()  
 - 배열을 List로 변환 - asList(Object a)  
 
 ##  Comparator와 Comparable  
 - 객체 정렬에 필요한 메서드를 정의한 인터페이스  
 - 정렬 기준을 제공한다.  
 - compare()와 compareTo()는 두 객체의 비교결과를 반환하도록 작성되었고, 같으면 0, 오륹쪽이크면 음수, 왼쪽이 크면 양수이다.  
 
 ## HashSet 
 - 순서 x , 중복 x  
 - Set인터페이스를 구현한 대표적인 컬렉션 클래스  
 - 순서를 유지하려면 LinkedHashSet클래스 사용하면 된다.  
 - HashSet은 객체를 저장하기전에 기존에 같은 객체가 있는지 확인 // 같은 객체가 있으면 저장하지않는다.  
 - 중복을 확인하기 위해서 equals()와 hashCode()가 오버라이딩 되어 있어야함.  
 
 ##  TreeSet  
 - 이진 탐색 트리. 범위 탐색(from- to)과 정렬에 유리하다.  
 - 이진트리는 모든 노드가 최대 2개이하의 하위노드를 가진다.  
 - 이진 탐색 트리 : 부모보다 작은 값은 왼쪽, 큰값은 오른쪽에 저장  
 - 이진 탐색 트리의 단점: 데이터가 많아질 수 록 추가,삭제에 시간이 더 걸린다.  
 - TreeSet 데이터 저장에는 add메서드 사용  
 












