# Operator
연산자: 연산을 수행하는 기호  
피연산자: 연산자의 연산 수행 대상  
## 연산자 종류  
1. 산술연산자 : +,-,*,/,%  
2. 비교연산자: >,<...  
3. 논리연산자: &&,||,!  
4. 대입연산자: =  
5. 기타: 삼항연산자  

## 연산자의 우선순위 
어떤 연산을 수행할지 자동으로 결정된다.  
수동으로 결정하려면 괄호()를 이용해 수동 결정한다.  

* 대입과 단항 연산자를 제외하면, 모두 왼쪽->오른쪽으로 연산  
           - ex) 3+4-5 ->2  
           - ex) x=y=3 -> x=3  
 
## 증감 연산자 '++' '--'
증가 연산자(++) 피연산자 값을 1증가시킨다.  
감소 연산자(--) 피연산자 값을 1감소시킨다.  
>타입  
>>전위형: 값이 참조되기전에 증가 ex) j=++i;  
>>후위형: 값이 참조된 후에 증가 ex) j=i++;  
**증감 연산자가 독립적으로 사용된 경우, 전위형 후위형 차이가 없다.**  

## 부호연산자 '-'
'-'는 피연산자의 부호를 반대로 변경해주는 역할  
## 형변환 연산자 : (type)피연산자
변수 또는 상수의 타입을 다른 타입으로 변환  
|변환|수식|결과|
|---|---|---|
|int->char|(char)65|'A'|
|char->int|(int)'A'|65|
|float->int|(int)1.6f|1|
|int->float|(float)|10.0f| 

컴퓨터는 모든것을 숫자로 바꿔서 처리하므로 입력하는 데이터들은 숫자로 처리됨(ex 문자)
유니코드 문자표를 이용해서 문자형 숫자를 문자로 변환  

## 자동 형변환 
**작은 값을 큰 값에 넣을 경우**  
ex)float f=1234;  // 1234는 int형 f는 float형이므로 1234가 f에 들어갈때 자동 형변환  
ex) int i =3.14f; // error!  3.14f가 i보다 크기때문에 수동 형변환 해줘야함 
    int i=(int)3.14f // i=3 값손실 발생  
    
**예외**  
1. byte b= 100;  // byte 범위 -128~127  자동 컴파일 됨  
2. int i=100;  
   byte b= i;    // error!    i는 변수이므로 컴파일러가 i안의 값을 확신x  수동컴파일 해야함
3. byte b= 1000;  // error!   byte 범위(-128~127)를 벗어난 값  수동컴파일 해야함

byte->int  
ex)byte b= 10; int i= b; // int 생략 가능  
int ->byte  
ex)int ii=300; byte bb=(byte)ii;  // 생략이 불가능하다. 값손실이 일어났기 때문(300->44)

## 산술 변환  
"연산 전에 피연산자의 타입을 일치시키는 것"  
1. 두 피연산자의 타입을 같게 일치시킨다.(더 큰 타입으로 일치)  
           float+ int -> float +float ->float  
2. 피연산자 타입이 int보다 작은 타입이면 int로 변환  
           byte+ short ->int +int ->int  
           char의 경우 문자코드를 이용  

## Math.round()  
실수를 소수 첫째자리에서 반올림한 정수 반환  
long result = Math.round(4.52);   // 5 반환  

## 문자열의 비교 
문자열 비교에는 == 대신 equals()를 사용  
String str1= "abc";  
String str2= "abc";  
System.out.println(str1.equals(str2))

## 조건연산자 ? : (삼항연산자)  
참 또는 거짓 반환  
조건식의 결과에 따라 연산결과를 달리한다.  
result = (x>y) : x: y ;    // 참일때 x, 거짓일때 y 반환  



