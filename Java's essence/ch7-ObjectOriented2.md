# 객체지향언어 2

## 상속
- 기존의 클래스로 새로운 클래스 작성(코드 재사용)  
- 두 클래스를 부모와 자식관계로 연결  
- 자손은 조상의 모든 멤버를 상속받음.  
- 자손의 변경은 조상에 영향x( 조상의 변경은 영향 o)  
- class child extends parent{}  

## 포함
- 클래스의 멤버로 참조변수 선언 
- 작은 단위의 클래스를 만들고 이 들을 조합해서 새로운 클래스 생성  


## 단일 상속 
- 자바는 단일상속만 허용한다.(하나의 부모로부터만 상속)   ex) class TVdvd extends tv, dvd{...} // error!  
- 비중이 높은 클래스하나만 상속관계로, 나머지는 포함관계로 하면 해결되다.  
- object클래스는 모든 클래스의 조상. 부모가 없는 클래스는 자동적으로 object 클래스를 상속받는다.  
- 모든 클래스는 object 클래스에 정의된 11개 메서드를 상속받는다. ex) toString(), equals()...  

## 오버라이딩
- 상속받은 조상의 메서드를 자신에 맞게 변경하는 것 
- 구현부(내용)만 바꿀 수 있다.  


### 오버라이딩 조건
1. 선언부가 조상 클래스의 메서드와 일치해야함.  
2. 접근제어자를 조상클래스의 메서드보다 좁은범위로 변경할수 없다.  //  접근제어자: public , protected, default..  
3. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.  


## 오버로딩vs 오버라이딩 
오버로딩: 기존에 없는 새로운 메서드를 정의하는 것  
오버라이딩: 상속받은 메서드의 내용을 변경하는 것

## 참조변수 super
- 객체 자신을 가리키는 참조변수. 인스턴스 메서드(생성자) 내에서만 존재  
- 조상의 멤버와 지신의 멤버를 구별할때 사용  

## super() - 조상의 생성자
- 조상의 성성자 호출할때 사용  
- 생성자, 초기화 블록은 상속되지 않는다.  
- 생성자 첫줄에 반드시 생성자를 호출해야한다.! 그렇지 않으면 컴파일러가 생성자 첫줄에 super() 삽입  

## 패키지
- 서로 관련된 클래스의 묶음  
- 클래스는 클래스(*.clalss)파일, 패키지는 폴더. 하위 패키지는 하위 폴더
- 클래스의 실제이름은 패캐지를 포함 (java.lang.String)
- 패키지는 소스파일의 첫번째 문장으로 단 한번 선언된다.

## import문
- 클래스를 사용할때 패키지 이름 생략 할 수 있다.  import java.util.Date;  
- 이클립스 단축기 ctrl+shift+o  
- java.lang패키지의 클래스는 import 하지 않고도 사용 가능하다. ex) String, System,Object..  

### import문 선언  
- import 패키지명.클래스명;  or import.*; // *는 모든 클래스  
- 패키지문과 클래스선언 사이에 선언  

### static  import문  
- static멤버를 사용할 때 클래스 이름을 생략할 수 있게 해준다.  
- import static java.lang.Math.random; // Math  클래스 생략가능  

## 제어자 
- 클래스와 클래스 멤버에 부가적인 의미 부여  
- 접근제어자(public, protected,default,private), 그외 static,final,abstract.... 
- 하나의 대상에 여러 제어자를 같이 사용가능하다. ex) public static final int ~ // 접근제어자는 제일 왼쪽에  

### static  
- iv앞에 붙으면 cv(클래스 변수)가 된다.  
- static { }  // 복잡한 초기화 수행(초기화 블럭)  
- 메서드 앞에 static 붙이면 클래스 메서드  

### final- 마지막의, 변경될 수 없는 
- 조상이 될 수 없는 클래스 (상속 계층도의 젤 마지막)  
- 변수에 붙으면 값을 변경할 수 없는 상수  
- 메서드에 붙으면 오버라이딩 할 수 없는 메서드  

### abstract - 추상의, 미완성의  
- 구현부가 없는 메서드를 abstract 메서드라고 한다.  
- abstract 클래스는 abstract 메서드를 포함한 클래스이다.  
- 메서드가 미완성이므로 클래스도 미완성이다. 따라서 인스턴스 생성  불가하다.  

## 접근제어자  
- public : 접근 제한이 없다.  
- protected: 같은 패키지내에서, 그리고 다른 패키지의 자손클래스에서 접근 가능  
- default: 같은 패키지내에서  
- private: 같은  클래스내에서  

class 앞에 붙일 수 있는 접근제한자는 public , (default) 
변수,메서드 앞에  붙일 수 있는 접근제한자는 모든 접근제한자  

## 캡슐화, 접근제어자  
- 접근제어자를 사용하는 이유: 외부로부터 데이터 보호하기 위해  
- 간접접근 허용하게 하는 것  

## 다형성 
- 여러가지 형태를 가질 수 있는 능력  
- 겍체와 참조변수의 타입이 일치하지 않을때   ex) Tv t= new SmartTv();  
- 자손타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.  ex) SmartTV s= new Tv(); // error!  

## 참조변수 형변환  
- 사용할 수 있는 멤버의 갯수를 조절한다.  
- 조상과 자손 관계의 참조변수는 형변환 가능하다.  
-  ex) car= (Car)fe;    // car은 Car클래스 참조변수  fe는 Car의 자식클래스인 FireEngine의 참조변수.  car가 Car클래스이므로 fe를 형변환한다.  

## instanceof 연산자 
- 참조변수 형변환 가능여부 확인에 사용한다.  가능하면 true 반환  
- ex) c instanceof FireEngine  ?   // true면 FireEngine으로 형변환 가능

## 매개변수의 다형성  
- 참조형 매게변수는 메서드 호출시 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨 줄 수 있다.  
- 메서드의 매개변수로 조상타입의 참조변수를 사용해서 하나의 메서드로 여러타입의 객체를 받을 수 있다.  

## 추상클래스,메서드
- 미완성 메서드라고도 불리며, 구현부(몸통)가 없는 메서드이다.  
- 추상 메서드를 가지고있으면 추상클래스이다.  
- 메서드앞에 abstract를 붙인다.  
- 클래스앞에도 abstract를 붙인다.  
- 미완성 설계도이므로 제품(인스턴스) 생성 불가하다.  
- 상속을 통해 추상메서드를 완성해야 인스턴스 생성가능하다.  
- 구현: 추상메서드의 몸통을 만들어주는것  

## 추상화와 구체화  
- 추상화: 불명확한 것 / 구체화된 코드보다 유연하다.(변경에 유리)    
- 구체화: 명확한 것  

## 인터페이스  
- 추상 메서드의 집합  !!
- 구현된것이 전혀 없는 설계도, 껍데기, 제일 바깥에 있으므로 모든 멤버가 public  
- 추상클래스는 클래슨데 추상메서드를 가지고있는것이고, 인터페이스는 추상메서드만의 집합이다. 또 인터페이스는 iv 가질 수 없다.  
- interface 인터페이스이름 {...}  
- 모든 인터페이스의 멤버는 public이면서 추상메서드  
- 인터페이스에서는 public , abstract 생략 가능  
- 인터페이스 멤버인 상수도 항상 public ,static ,final이다.  

### 인터페이스의 상속  
- 인터페이스의 조상은 인터페이스만 가능( Object가 최고 조상 아님)  
- 다중 상속이 가능하다. interface Fightable extends Movable,Attackable {} // class와는 다르게 추상메서드는 충돌해도 문제가 없다.(몸통이 없으므로)  

## 인터페이스의 구현  
- 인터페이스에 정의된 추상 메서드를 완성하는 것  
- 미완성 설계도  
- class 클래스이름 implements 인터페이스이름 { }  // 인터페이스에 정의된 추상메서드 모두 구현해야함   
- 일부만 구현하는 경우, 클래스앞에 abstract를 붙여야함.   

### 인터페이스를 이용한 다형성  
- 다중상속의 문제는 충돌이였는데 부모 클래스와 부모 인터페이스에 이름이 같은 메서드가 있어도 인터페이스는 구현부가 없으므로 충돌해도 상관없다.  
- 매개변수의 타입이 인터페이스인경우 인터페이스를 구현한 클래스의 객체만 가능하다.  
- 인터페이스를 메서드의 리턴타입으로 지정 가능하다.  

### 인터페이스의 장점  
- inter: ~간에(~사이에) , face: 얼굴(대상)  // 즉 두 대상사이에 있는 것  
- 소통을 도와주는 역할(중간역할)  // ex) window 사람과 컴퓨터의 중간역할  
- 선언(껍데기)과 구현(알멩이)를 분리시킬 수 있다.   -> 개발시간 단축 , 변경에 유리함.  
- 서로 관계없는 클래스들의 관계를 맺어줄 수 있다.

## 디폴드메서드, 스태틱메서드 
- 인터페이스에 디폴트메서드, static메서드를 추가했다.  
- 디폴트 메서드는 인스턴스메서드로 인터페이스 원칙을 위반한다.  
- 디폴트메서드가 기존의 메서드와 충돌 할때 해결책
-  1. 여러 인터페이스의 디폴트 메서드간의 충돌  : 인터페이스를 구현한 클래스에서 디폴트 메서드를 직접 오버라이딩 해야한다.    
-  2. 디폴트 메서드와 조상클래스의 메서드 간의 충돌: 조상클래스의 메서드가 상속된다.  

## 내부 클래스 
- 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근 가능  
- 코드의 복잡성 줄일 수 있다.  

### 내부클래스의 제어자와 접근성  
- 내부클래스의 제어자는 변수에 사용 가능한 제어자와 동일핟다. Ex) public,private,protected,default  
- 일반클래스는 제어자가 public, default밖에 안된다.  

## 익명클래스 
- 이름이 없는 일회용 클래스  
- 클래스의 정의와 객체 생성 동시에  
- new 조상클래스이름() {...}  


